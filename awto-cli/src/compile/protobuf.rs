use std::fmt::Write;
use std::path::Path;

use anyhow::{anyhow, Context, Result};
use async_trait::async_trait;
use clap::{AppSettings, Clap};
use colored::Colorize;
use log::info;
use tokio::fs;

use crate::{util::CargoFile, Runnable};

use super::{build_awto_pkg, prepare_awto_dir};

/// Compiles protobuf package from app service
#[derive(Clap)]
#[clap(setting = AppSettings::ColoredHelp)]
pub struct Protobuf {
    /// Prints more information
    #[clap(short, long)]
    pub verbose: bool,
}

#[async_trait]
impl Runnable for Protobuf {
    async fn run(&mut self) -> Result<()> {
        let cargo_file = CargoFile::load("./service/Cargo.toml")
            .await
            .context("could not load service Cargo.toml file from './service/Cargo.toml'")?;
        if cargo_file
            .package
            .as_ref()
            .map(|package| package.name != "service")
            .unwrap_or(false)
        {
            match cargo_file.package {
                Some(package) => {
                    return Err(anyhow!(
                        "service package must be named 'service' but is named '{}'",
                        package.name
                    ));
                }
                None => return Err(anyhow!("service package must be named 'service'")),
            }
        }

        prepare_awto_dir().await?;

        Self::prepare_protobuf_dir().await?;
        build_awto_pkg("protobuf").await?;

        let show_extended_message = CargoFile::load("./Cargo.toml")
            .await
            .map(|cargo_file| {
                cargo_file
                    .workspace
                    .map(|workspace| workspace.members)
                    .map(|members| members.contains(&"awto/protobuf".to_string()))
                    .unwrap_or(false)
            })
            .unwrap_or(false);
        if show_extended_message {
            info!("compiled package 'protobuf'");
        } else {
            info!(
                "compiled package 'protobuf'{}",
                format!(
                    r#"

- add it to your workspace Cargo.toml
  {}

- import it in a package
  {}

{}
"#,
                    format!(
                        r#"{}{}{}"#,
                        "members = [".italic().truecolor(100, 100, 100),
                        r#""awto/protobuf""#.white(),
                        r#", "schema", "service"]"#.italic().truecolor(100, 100, 100)
                    ),
                    r#"protobuf = { path = "../awto/protobuf" }"#.white(),
                    r#"add "awto/protobuf" to your workspace to hide this message"#
                        .italic()
                        .truecolor(100, 100, 100)
                )
                .truecolor(190, 190, 190)
            );
        }

        Ok(())
    }

    fn is_verbose(&self) -> bool {
        self.verbose
    }
}

impl Protobuf {
    const PROTOBUF_DIR: &'static str = "./awto/protobuf";
    const PROTOBUF_SRC_DIR: &'static str = "./awto/protobuf/src";
    const PROTOBUF_CARGO_PATH: &'static str = "./awto/protobuf/Cargo.toml";
    const PROTOBUF_CARGO_TOML_BYTES: &'static [u8] =
        include_bytes!("../templates/protobuf/Cargo.toml");
    const PROTOBUF_BUILD_PATH: &'static str = "./awto/protobuf/build.rs";
    const PROTOBUF_BUILD_BYTES: &'static [u8] = include_bytes!("../templates/protobuf/build.rs");
    const PROTOBUF_LIB_PATH: &'static str = "./awto/protobuf/src/lib.rs";

    async fn prepare_protobuf_dir() -> Result<()> {
        if Path::new(Self::PROTOBUF_DIR).is_dir() {
            fs::remove_dir_all(Self::PROTOBUF_DIR)
                .await
                .with_context(|| format!("could not delete directory '{}'", Self::PROTOBUF_DIR))?;
        }

        fs::create_dir(Self::PROTOBUF_DIR)
            .await
            .with_context(|| format!("could not create directory '{}'", Self::PROTOBUF_DIR))?;

        fs::create_dir(Self::PROTOBUF_SRC_DIR)
            .await
            .with_context(|| format!("could not create directory '{}'", Self::PROTOBUF_SRC_DIR))?;

        fs::write(Self::PROTOBUF_CARGO_PATH, Self::PROTOBUF_CARGO_TOML_BYTES)
            .await
            .with_context(|| format!("could not write file '{}'", Self::PROTOBUF_CARGO_PATH))?;

        fs::write(Self::PROTOBUF_BUILD_PATH, Self::PROTOBUF_BUILD_BYTES)
            .await
            .with_context(|| format!("could not write file '{}'", Self::PROTOBUF_BUILD_PATH))?;

        let mut lib_content = concat!(
            "// This file is automatically @generated by ",
            env!("CARGO_PKG_NAME"),
            " v",
            env!("CARGO_PKG_VERSION"),
            "\n\n"
        )
        .to_string();

        writeln!(
            lib_content,
            r#"include!(concat!(env!("OUT_DIR"), "/app.rs"));"#
        )
        .unwrap();

        fs::write(Self::PROTOBUF_LIB_PATH, lib_content)
            .await
            .with_context(|| format!("could not write file '{}'", Self::PROTOBUF_LIB_PATH))?;

        Ok(())
    }

    // async fn read_services() -> Result<Vec<String>> {
    //     let service_lib = fs::read_to_string("./service/src/lib.rs")
    //         .await
    //         .context("could not read file './service/src/lib.rs'")?;
    //     let lib = syn::parse_file(&service_lib).context("could not parse service source code")?;
    //     lib.items
    //         .into_iter()
    //         .find_map(|item| {
    //             if let syn::Item::Macro(syn::ItemMacro { mac, .. }) = item {
    //                 let macro_name = mac
    //                     .path
    //                     .segments
    //                     .iter()
    //                     .map(|segment| segment.ident.to_string())
    //                     .collect::<Vec<_>>()
    //                     .join("::");
    //                 if macro_name != "awto::register_services" && macro_name != "register_services" {
    //                     return None;
    //                 }

    //                 let services: Vec<_> = mac
    //                     .tokens
    //                     .into_iter()
    //                     .filter_map(|token| match token {
    //                         TokenTree::Ident(ident) => Some(ident.to_string()),
    //                         _ => None,
    //                     })
    //                     .collect();

    //                 Some(services)
    //             } else {
    //                 None
    //             }
    //         })
    //         .ok_or_else(|| {
    //             anyhow!("no services registered with the 'awto::register_services!' macro\n\n   Services must be registered:\n      `awto::register_services!(ServiceOne, ServiceTwo)`")
    //         })
    // }
}
